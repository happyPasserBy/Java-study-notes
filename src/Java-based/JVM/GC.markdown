# Java垃圾清除
## 什么方法可以被判定某个对象为垃圾？
> 应用计数法:
>> 一个对象如果有其他对象引用则计数器+1,当计数器为0时则标记为垃圾

1. 优点:
    1. 执行效率高，程序受到的影响小
2. 缺点: 
    1. 无法识别循环引用，容易出现内存泄漏
> 可达性分析法
>> 从GC Roots开始，根据对象的引用生成 Reference Chain,一个对象如果不存在于Reference Chain中说明不可达标则记为垃圾
1. GC Roots对象
    1. 虚拟机栈中的引用对象
    2. 方法区中的常量引用对象
    3. 方法区中的类静态应用对象
    4. 本地方法中JNI的引用对象
    5. 活跃线程的引用对象 
## 清除算法
> 标记-清除
1. 清除步骤
    * 标记: 从根进行扫描，利用具体对象的分析算法，对存活的对象进行标记
    * 清除: 对堆内存进行线性遍历，回收垃圾对象
2. 缺点
   *  内存碎片化，当要存储一个较大对象时，当前内存不够需提前进行GC或者抛出内存异常
> 复制算法
1. 清除步骤
    * 将内存空间按照一定比例分为两块或者多块，其中一部分为对象面，另一部分为空闲面
    * 对象存储在对象面上
    * 将存活的对象从对象面复制到空闲面
    * 将对象面内剩余的垃圾清除
2. 优点 
    * 解决碎片化问题，在将存活的对象拷贝到空闲面时会分配连续的内存空间
    * 顺序分配内存，简单高效
    * 适用于对象存活率低的场景(存活率低，说明需要复制的对象较少)
3. 缺点
    * 需要预留50%空间用于复制对象(具体比例待查)
    * 不适用于拥有较大，较多内存块的场景
> 标记-整理算法(压缩算法)
1. 清除步骤
    * 运用可达性算法标记标记对象
    * 将存活的对象按照顺序集中存储
    * 回收垃圾对象
2. 优点
    * 避免内存的不连续性
    * 不用设置两块内存互换
    * 适用于存活率高的场景
> 分代收集算法
1. 将内存堆的内存空间分为年轻代与老年代,按照对象的存活时间将其存放在不同的内存区域中
2. 年轻代
    * 定义； 用于存活时间较短的对象，内部又分为三个空间(Eden、form Survivor、to Survivor)
    * 清除算法
        1. 标记-复制
    * 区域划分
        1. Eden区(伊甸园，亚当夏娃居住的地方，也可以称为人类起源的地方)
            * 占用年轻代(8/10)的区域  
            * 对象最初存放的地方，如果存放不下可能直接存放在Survivor或老年代中
        2. 两个Survivor区
            * 两个Survivor分别是(1/10)
        3. 年轻代清除步骤(Minor GC)
            * 对象最初存储于Eden中
            * 当Eden空间被占满则触发Minor GC进行回收，将存活的对象年龄加1并存储到其中一个Survivor中(假设当前Survivor名为S1,如果Survivor放不下则放入老年代)
            * 以上步骤周而复始当S1存储被占满，如果剩下的另一个Survivor(假设名为S2)可以存放S1的对象，则将S1的对象复制到S2，如放不下，则将放不下的对象直接放入老年代
    * 对象何时移动到老年代
        1. 经历过一定次数Minor GC仍然存活的对象
        2. Eden、Survivor区放不下的对象
        3. 新生成的对象大于指定的size
3. 老年代
    * 定义: 存放存活时间较长的对象
    * 清除算法
        1. 标记-清除
        2. 标记-整理
1. GC的分类与垃圾收集器
    * Minor GC 大部分情况用于年轻代的垃圾回收
    * Full GC 大部分情况用于老年代的垃圾回收
        1. 触发条件
            * 老年代空间不足
            * 永久代空间不足(JDK8以废弃)
            * CMS GC时出现promition failed、concurrent mode failure
            * Minor GC晋升到老年代的平均大小大于老年代剩余空间
            * 调用System.gc() (调用后不会立刻触发GC，而是在此处标记，告诉虚拟机这里需要GC)
            * 使用RMI来进行RPC或管理的JDK应用，每小时执行一次Full GC
    * Stop the world
        1. 定义: JVM执行GC而停止应用程序的执行，任何一种GC算法都会发生Stop the world，而减少Stop the World是GC优化的重要手段
    * 垃圾收集器
        1. Serial收集器(-XX:UseSerialGC,复制算法，用于年轻代,单线程收集)
        2. ParNew收集器(-XX:UseParNewGC,复制算法，用于年轻代，多线程收集)
        3. Parallel Scaveng收集器(-XX:UseParallelGC,复制算法，用于年轻代，多线程收集且更关注系统吞吐量)
        4. Serial Old收集器(-XX:UseSerialOldGC,标记-整理算法，用于老年代)
        5. Parallel Old收集器(-XX:UseParallelOldGC,标记-整理算法，用于老年代)
        5. CMS收集器(-XX:UseConcMarkSweepGC,标记-清除算法，用于老年代)
            * 标记初始化: stop the world
            * 并发标记: 并发追溯标记，程序不会停止
            * 并发预处理: 查找执行并发标记阶段从年轻代到老年代的对象
            * 重新标记: 暂停虚拟机，扫描CMS堆中的剩余对象
            * 并发清理: 清理垃圾对象，程序不会停顿
            * 并发重置：重置CMS收集器的数据结构
            * 缺点: CPU敏感、浮动垃圾、空间碎片
        6. G1收集器：(-XX:UseG1 复制+标记整理算法)
            * 可以并行并发，分代收集，空间整合，可预测停顿。
            * G1将Java堆内存划分成多个大小相同的的Region,
            * 年轻代与老年代不在物理隔离
            * 初始标记(存活对象的初始标记被固定放在年轻代垃圾收集阶段进行的，之所以把他列为第一个阶段，是因为只有进行初始标记了才有后续的阶段， 在日志中被记为 GC pause (young)(inital-mark))
            * 并发标记阶段(如果发现有空的块, 则会在 Remark 阶段立即移除。当然,”清单(accounting)”信息决定了活跃度的计算)
            * 重新标记阶段(空的区域块被移除并回收。计算所有区域块的活跃度(Region liveness))
            * 复制清除阶段(G1选择“活跃度(liveness)”最低的区域块，这些区域可以最快的完成回收。然后这些区域和年轻代GC在同时被垃圾收集 。 日志上是被标识为 [GC pause (mixed)]。所以年轻代和老年代都在同一时间被垃圾收集)
            * 复制/清除之后阶段
 
    
## 参考链接
1. https://coding.imooc.com/class/303.html
2. https://www.cnblogs.com/ASPNET2008/p/6496481.html
3. https://mp.weixin.qq.com/s/ZwlT89vsvD2e0qEuxZto3Q




